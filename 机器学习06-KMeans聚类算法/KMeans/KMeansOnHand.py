# encoding:utf-8import numpy as npfrom sklearn.cluster import KMeansimport matplotlib.pyplot as pltplt.figure(figsize=(12, 12))def loadDataSet(fileName):    '''         list集合    '''    dataMat = []    fr = open(fileName)    for line in fr.readlines():        curLine = line.strip().split('\t')        fltLine = list(map(float, curLine))        dataMat.append(fltLine)    return dataMat  # 返回一个元素为代表数据点坐标的二元列表的列表'''np.power() 数组元素求n次方np.sqrt() 数组元素求平方根'''def distEclud(vecA, vecB):    return np.sqrt(np.sum(np.power(vecA - vecB, 2)))'''    第一次选取3个中心点的坐标'''def randCent(dataSet, k):    n = np.shape(dataSet)[1]    '''        centroids是一个3*2的矩阵，用于存储三个中心点的坐标    '''    centroids = np.mat(np.zeros((k, n)))  #得到一个能够装下k个中心点的 k*n 矩阵    for j in range(n):        minJ = np.min(dataSet[:, j]) # 得到j列的最小值        rangeJ = np.max(dataSet[:, j]) - minJ  # 得到j列的振幅        centroids[:, j] = np.mat(minJ + rangeJ * np.random.rand(k, 1)) # np.random.rand(k,1)返回一个由[0,1)的数值填充的k*1矩阵    return centroids  # 返回一个随机获得的初始中心点矩阵def kMeans(dataSet, k, distMeas=distEclud, createCent=randCent):    m = np.shape(dataSet)[0]   # 得到数据集行数    clusterAssment = np.mat(np.zeros((m, 2))) # 得到与数据集同等形状的以零填充的矩阵，用于后面记录每个点的最近中心点的类型和距离    #     createCent找到K个随机中心点    centroids = createCent(dataSet, k)    clusterChanged = True    while clusterChanged:        clusterChanged = False        for i in range(m):            minDist = np.inf # 无穷大            minIndex = -1            for j in range(k):                x = centroids[j, :]                distJI = distMeas(x, dataSet[i, :]) # 计算该数据点与每一个中心点的距离                if distJI < minDist:                    minDist = distJI                    minIndex = j            if clusterAssment[i, 0] != minIndex: clusterChanged = True # 但凡有一个点的最近距离中心点类型发生改变，则进入下一个大循环            clusterAssment[i, :] = minIndex, minDist        for cent in range(k):            # nonzero返回符合条件的数据的索引值，索引值为二元组(array([x,x,x,x]),array([0,0,0,0]))            ptsInClust = dataSet[np.nonzero(clusterAssment[:, 0].A == cent)[0]] # 得到以该中心点类型为分类的数据点集合            centroids[cent, :] = np.mean(ptsInClust, axis=0)  #压缩行，对各列求均值，返回 1* n 矩阵；即选取新的中心点    return centroids, clusterAssmentif __name__ == '__main__':    dataMat = np.mat(loadDataSet('testSet.txt'))  #得到代表数据集的 80*2 矩阵    k = 4    centroids, clusterAssment = kMeans(dataMat, k, distMeas=distEclud, createCent=randCent)    # print(clusterAssment)    # print(centroids)    # 将聚类的结果使用散点图的形式展现出来    dataMat = np.array(dataMat)    # 存储每一个样本的分类号    y_pred1 = np.array([int(i) for j in clusterAssment[:, 0].A for i in j])    plt.subplot(224)    plt.scatter(dataMat[:, 0], dataMat[:, 1], c=y_pred1)    plt.title("kmeans04")    plt.show()